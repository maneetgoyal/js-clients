{"version":3,"file":"createApplyLiveQueryPatch.js","sourceRoot":"","sources":["../../../src/graphql-live-query-utils/createApplyLiveQueryPatch.ts"],"names":[],"mappings":";;;AAAA,mDAAgD;AAkBhD;;GAEG;AACI,MAAM,yBAAyB,GACpC;AACE,uDAAuD;AACvD,UAA4C,EAC5C,EAAE,CACF,CAA6C,MAAuC,EAAE,EAAE,CACtF,IAAI,mBAAQ,CAAmB,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE;IAClD,MAAM,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;IAChD,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,WAAC,OAAA,MAAA,QAAQ,CAAC,MAAM,wDAAI,CAAA,EAAA,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IACxD,IAAI,WAAW,GAA2B,IAAI,CAAC;IAC/C,IAAI,YAAY,GAAG,CAAC,CAAC;IACrB,IAAI,IAA4D,CAAC;IACjE,6BAA6B;IAC7B,OAAO,CAAC,IAAI,GAAG,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,KAAK,KAAK,EAAE;QACpD,iDAAiD;QACjD,IAAI,UAAU,IAAI,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;YACnD,MAAM,cAAc,GAA6B,EAAE,CAAC;YAEpD,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,KAAK,CAAC,EAAE;gBAC7B,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE;oBACpB,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;iBAClC;gBACD,cAAc,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gBACtC,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gBAC9B,YAAY,GAAG,CAAC,CAAC;aAClB;iBAAM;gBACL,IAAI,CAAC,WAAW,EAAE;oBAChB,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;iBAC/C;gBACD,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE;oBACrB,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,CAAC;iBACnC;gBACD,IAAI,YAAY,GAAG,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;oBAC5C,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;iBAC7C;gBAED,WAAW,GAAG,UAAU,CAAC,WAAsC,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBACnF,cAAc,CAAC,IAAI,GAAG,EAAE,GAAG,WAAW,EAA6B,CAAC;gBAEpE,YAAY,EAAE,CAAC;aAChB;YAED,IAAI,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE;gBACzB,cAAc,CAAC,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC;aACnD;YACD,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;gBACrB,cAAc,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;aAC3C;YAED,MAAM,IAAI,CAAC,cAAkC,CAAC,CAAC;YAC/C,SAAS;SACV;QAED,MAAM,IAAI,CAAC,IAAI,CAAC,KAAyB,CAAC,CAAC;KAC5C;IAED,IAAI,EAAE,CAAC;AACT,CAAC,CAAC,CAAC;AAzDI,QAAA,yBAAyB,6BAyD7B","sourcesContent":["import { Repeater } from \"../repeater/index.js\";\nimport type { ExecutionResult } from \"graphql\";\n\nexport type ExecutionLivePatchResult<PatchPayload = unknown> = {\n  errors?: ExecutionResult[\"errors\"];\n  /* data must be included in the first result */\n  data?: ExecutionResult[\"data\"];\n  /* patch must be present in the next results */\n  patch?: PatchPayload;\n  revision?: number;\n  extensions?: ExecutionResult[\"extensions\"];\n};\n\nexport type ApplyPatchFunction<PatchPayload = unknown> = (\n  previous: Record<string, unknown>,\n  patch: PatchPayload\n) => Record<string, unknown>;\n\n/**\n * Create a middleware generator function for applying live query patches on the client.\n */\nexport const createApplyLiveQueryPatch =\n  <PatchPayload = unknown>(\n    /* Function which is used for generating the patches */\n    applyPatch: ApplyPatchFunction<PatchPayload>\n  ) =>\n    <TExecutionResult = Record<string, unknown>>(source: AsyncIterable<TExecutionResult>) =>\n      new Repeater<TExecutionResult>(async (push, stop) => {\n        const iterator = source[Symbol.asyncIterator]();\n        stop.then(() => iterator.return?.()).catch(console.log);\n        let mutableData: ExecutionResult | null = null;\n        let lastRevision = 0;\n        let next: IteratorResult<ExecutionLivePatchResult<PatchPayload>>;\n        // @ts-expect-error bad types\n        while ((next = await iterator.next()).done === false) {\n          // no revision means this is no live query patch.\n          if (\"revision\" in next.value && next.value.revision) {\n            const valueToPublish: ExecutionLivePatchResult = {};\n\n            if (next.value.revision === 1) {\n              if (!next.value.data) {\n                throw new Error(\"Missing data.\");\n              }\n              valueToPublish.data = next.value.data;\n              mutableData = next.value.data;\n              lastRevision = 1;\n            } else {\n              if (!mutableData) {\n                throw new Error(\"No previousData available.\");\n              }\n              if (!next.value.patch) {\n                throw new Error(\"Missing patch.\");\n              }\n              if (lastRevision + 1 !== next.value.revision) {\n                throw new Error(\"Wrong revision received.\");\n              }\n\n              mutableData = applyPatch(mutableData as Record<string, unknown>, next.value.patch);\n              valueToPublish.data = { ...mutableData } as Record<string, unknown>;\n\n              lastRevision++;\n            }\n\n            if (next.value.extensions) {\n              valueToPublish.extensions = next.value.extensions;\n            }\n            if (next.value.errors) {\n              valueToPublish.errors = next.value.errors;\n            }\n\n            await push(valueToPublish as TExecutionResult);\n            continue;\n          }\n\n          await push(next.value as TExecutionResult);\n        }\n\n        stop();\n      });\n"]}